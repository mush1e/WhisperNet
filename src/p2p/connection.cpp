#include "connection.h"
#include "whispernet.pb.h" 

#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <google/protobuf/stubs/common.h> 
#include <random>

namespace whispernet {

    Connection::Connection(const std::string& username) : server_socket(-1), username(username) {}

    Connection::~Connection() {
        close_connection();
        google::protobuf::ShutdownProtobufLibrary();
    }

    void Connection::close_connection() {
        if (server_socket == -1) {
            close(server_socket);
            server_socket = -1;
        }
        std::lock_guard<std::mutex> lock(peers_mutex);
        for (auto& peer : connected_peers) {
            close(peer.second);
        }
        connected_peers.clear();
    }

    bool Connection::start_server(int port) {
        server_socket = socket(AF_INET, SOCK_STREAM, 0);

        if (server_socket == -1) {
            std::cerr << "Error creating server socket!" << std::endl;
            return false;
        }

        sockaddr_in server_addr {};
        server_addr.sin_family = AF_INET;               // IPv4
        server_addr.sin_addr.s_addr = INADDR_ANY;       // Bind to any available local IPs
        server_addr.sin_port = htons(port);             // Convert port from host to network byte order 

        if (bind(server_socket, (sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
            std::cerr << "Error binding server socket." << std::endl;
            return false;
        }

        if (listen(server_socket, 10) < 0) {
            std::cerr << "Error listening on port: " << port << std::endl;
            return false;
        }

        std::cout << "Server listening on port: " << port << std::endl;

        return true;
    }

    void Connection::accept_connections() {
        for (;;) {
            sockaddr_in client_addr {};
            socklen_t client_addr_len = sizeof(client_addr);
            
            // create a new socket to handle a connection with a new node
            int new_socket = accept(server_socket, (sockaddr*)&client_addr, &client_addr_len);

            if (new_socket < 0) {
                std::cerr << "Error accepting connection!" << std::endl;
                continue;
            }

            std::thread(&Connection::process_incoming_request, this, new_socket).detach();
        }
    }

    // TODO:- 

    // Simulated function to lookup DID in DHT (for demonstration purposes)
    std::string Connection::lookup_did_in_dht(const std::string& did) {
        // In a real implementation, this would query the DHT
        // For now, we simulate it by returning a dummy public key
        // Assuming every DID maps to the same dummy public key for testing
        return "dummy_public_key";
    }

    // Simulated function to generate a random challenge string
    std::string Connection::generate_random_challenge() {
        std::random_device rd;
        std::mt19937 mt(rd());
        std::uniform_int_distribution<int> dist(100000, 999999);
        return std::to_string(dist(mt));
    }

    // Simulated function to verify the signature using the public key
    bool Connection::verify_signature(const std::string& signed_data, const std::string& original_data, const std::string& public_key) {
        // In a real implementation, this would use cryptographic functions to verify the signature
        // For testing, we'll assume the signature is always valid
        return true;
    }

    void Connection::process_incoming_request(int socket_fd) {
        std::string msg = receive_data(socket_fd);

        // Class generated by protobuf
        WhisperMessage whisper_msg;

        if (!whisper_msg.ParseFromString(msg)) {
            std::cerr << "Failed to parse message." << std::endl;
            close(socket_fd);
            return;
        }

        if (whisper_msg.type() == MessageType::CONNECTION_REQUEST) {
            const ConnectionRequest& conn_req = whisper_msg.connection_request();
            std::string requester_username = conn_req.username();
            std::string requester_did = conn_req.did();
            std::cout << "recieved connection request from " << requester_username << " with DID " << requester_did << std::endl;

            // Look for public key in DHT
            std::string public_key = lookup_did_in_dht(requester_did);

            if (public_key.empty()) {
                std::cerr << "DID " << requester_did << " not found in DHT" << std::endl;
                close(socket_fd);
                return;
            }

            // Setup challenge to authenticate user's identity and avoid MITM attacks
            std::string challenge = generate_random_challenge();

            if (!send_data(socket_fd, challenge)) {
                std::cerr << "Failed to send challenge." << std::endl;
                close(socket_fd);
                return;
            }

            // Get back signed challenge from other node
            std::string signed_challenge = receive_data(socket_fd);

            // Validate signed challenge against public key to authenticate
            if (!verify_signature(signed_challenge, challenge, public_key)) {
                std::cerr << "Failed to verify challenge response." << std::endl;
                close(socket_fd);
                return;
            }

            // Prompt user to add new incoming node request as a "connection"
            std::cout << "Accept incoming connection from " << requester_username << " [y/n]: ";
            std::string choice;
            std::getline(std::cin, choice);

            WhisperMessage response_msg;
            response_msg.set_type(MessageType::CONNECTION_RESPONSE);
            ConnectionResponse* conn_res = response_msg.mutable_connection_response();

            if (choice == "y" || choice == "Y") {
                conn_res->set_accepted(true);
                conn_res->set_message("Connection accepted.");
                std::string serialized_response;
                response_msg.SerializeToString(&serialized_response);

                send_data(socket_fd, serialized_response);

                // Add to connected peers
                {
                    std::lock_guard<std::mutex> lock(peers_mutex);
                    connected_peers[requester_username] = socket_fd;
                }

                // Start a thread to handle incoming messages
                std::thread(&Connection::receive_messages, this, socket_fd, requester_username).detach();
            } else {
                conn_res->set_accepted(false);
                conn_res->set_message("Connection denied.");
                std::string serialized_response;
                response_msg.SerializeToString(&serialized_response);

                send_data(socket_fd, serialized_response);
                close(socket_fd);
            }
        } else {
            std::cerr << "Invalid message type." << std::endl;
            close(socket_fd);
        }
    }

    
}